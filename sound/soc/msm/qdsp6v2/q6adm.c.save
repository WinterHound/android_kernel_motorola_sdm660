/* Copyright (c) 2012-2018, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/wait.h>
#include <linux/sched.h>
#include <linux/jiffies.h>
#include <linux/uaccess.h>
#include <linux/atomic.h>
#include <linux/wait.h>
#include <linux/qdsp6v2/apr.h>
#include <sound/apr_audio-v2.h>
#include <sound/q6adm-v2.h>
#include <sound/q6audio-v2.h>
#include <sound/q6afe-v2.h>
#include <sound/q6common.h>
#include <sound/audio_cal_utils.h>
#include <sound/asound.h>
#include <sound/q6core.h>
#include "msm-dts-srs-tm-config.h"
#include <sound/adsp_err.h>

#define TIMEOUT_MS 1000

#define RESET_COPP_ID 99
#define INVALID_COPP_ID 0xFF
/* Used for inband payload copy, max size is 4k */
/* 3 is to account for module, instance & param ID in payload */
#define ADM_GET_PARAMETER_LENGTH (4096 - APR_HDR_SIZE - 3 * sizeof(uint32_t))

#define ULL_SUPPORTED_BITS_PER_SAMPLE 16
#define ULL_SUPPORTED_SAMPLE_RATE 48000

#ifndef CONFIG_DOLBY_DAP
#undef DOLBY_ADM_COPP_TOPOLOGY_ID
#define DOLBY_ADM_COPP_TOPOLOGY_ID 0xFFFFFFFE
#endif

#ifndef CONFIG_DOLBY_DS2
#undef DS2_ADM_COPP_TOPOLOGY_ID
#define DS2_ADM_COPP_TOPOLOGY_ID 0xFFFFFFFF
#endif

struct adm_copp {

	atomic_t id[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t cnt[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t topology[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t mode[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t stat[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t rate[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t bit_width[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t channels[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t app_type[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t acdb_id[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	wait_queue_head_t wait[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	wait_queue_head_t adm_delay_wait[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t adm_delay_stat[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	uint32_t adm_delay[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	unsigned long adm_status[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
	atomic_t token[AFE_MAX_PORTS][MAX_COPPS_PER_PORT];
};

struct source_tracking_data {
	struct ion_client *ion_client;
	struct ion_handle *ion_handle;
	struct param_outband memmap;
	int apr_cmd_status;
};

struct adm_ctl {
	void *apr;

	struct adm_copp copp;

	atomic_t matrix_map_stat;
	wait_queue_head_t matrix_map_wait;

	atomic_t adm_stat;
	wait_queue_head_t adm_wait;

	struct cal_type_data *cal_data[ADM_MAX_CAL_TYPES];

	atomic_t mem_map_handles[ADM_MEM_MAP_INDEX_MAX];
	atomic_t mem_map_index;

	struct param_outband outband_memmap;
	struct source_tracking_data sourceTrackingData;

	int set_custom_topology;
	int ec_ref_rx;
	int num_ec_ref_rx_chans;
	int ec_ref_rx_bit_width;
	int ec_ref_rx_sampling_rate;

	int native_mode;
	u32 copp_token;
	int lsm_port_id;
for new ADM LSM cal types
};

static struct adm_ctl			this_adm;

struct adm_multi_ch_map {
	bool set_channel_map;
	char channel_mapping[PCM_FORMAT_MAX_NUM_CHANNEL];
};

#define ADM_MCH_MAP_IDX_PLAYBACK 0
#define ADM_MCH_MAP_IDX_REC 1
static struct adm_multi_ch_map multi_ch_maps[2] = {
							{ false,
							{0, 0, 0, 0, 0, 0, 0, 0}
							},
							{ false,
							{0, 0, 0, 0, 0, 0, 0, 0}
							}
};

static int adm_get_parameters[MAX_COPPS_PER_PORT * ADM_GET_PARAMETER_LENGTH];
static int adm_module_topo_list[MAX_COPPS_PER_PORT *
				ADM_GET_TOPO_MODULE_INSTANCE_LIST_LENGTH];

int adm_validate_and_get_port_index(int port_id)
{
	int index;
	int ret;

	ret = q6audio_validate_port(port_id);
	if (ret < 0) {
		pr_err("%s: port validation failed id 0x%x ret %d\n",
			__func__, port_id, ret);
		return -EINVAL;
	}

	index = afe_get_port_index(port_id);
	if (index < 0 || index >= AFE_MAX_PORTS) {
		pr_err("%s: Invalid port idx %d port_id 0x%x\n",
			__func__, index,
			port_id);
		return -EINVAL;
	}
	pr_debug("%s: port_idx- %d\n", __func__, index);
	return index;
}

int adm_get_default_copp_idx(int port_id)
{
	int port_idx = adm_validate_and_get_port_index(port_id), idx;

	if (port_idx < 0) {
		pr_err("%s: Invalid port id: 0x%x", __func__, port_id);
		return -EINVAL;
	}
	pr_debug("%s: port_idx:%d\n", __func__, port_idx);
	for (idx = 0; idx < MAX_COPPS_PER_PORT; idx++) {
		if (atomic_read(&this_adm.copp.id[port_idx][idx]) !=
			RESET_COPP_ID)
			return idx;
	}
	return -EINVAL;
}

int adm_get_topology_for_port_from_copp_id(int port_id, int copp_id)
{
	int port_idx = adm_validate_and_get_port_index(port_id), idx;
	if (port_idx < 0) {
		pr_err("%s: Invalid port id: 0x%x", __func__, port_id);
		return 0;
	}
	for (idx = 0; idx < MAX_COPPS_PER_PORT; idx++)
		if (atomic_read(&this_adm.copp.id[port_idx][idx]) == copp_id)
			return atomic_read(&this_adm.copp.topology[port_idx]
								  [idx]);
	pr_err("%s: Invalid copp_id %d port_id 0x%x\n",
		__func__, copp_id, port_id);
	return 0;
}

int adm_get_topology_for_port_copp_idx(int port_id, int copp_idx)
{
	int port_idx = adm_validate_and_get_port_index(port_id);
	if (port_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT) {
		pr_err("%s: Invalid port: 0x%x copp id: 0x%x",
				__func__, port_id, copp_idx);
		return 0;
	}
	return atomic_read(&this_adm.copp.topology[port_idx][copp_idx]);
}

int adm_get_indexes_from_copp_id(int copp_id, int *copp_idx, int *port_idx)
{
	int p_idx, c_idx;
	for (p_idx = 0; p_idx < AFE_MAX_PORTS; p_idx++) {
		for (c_idx = 0; c_idx < MAX_COPPS_PER_PORT; c_idx++) {
			if (atomic_read(&this_adm.copp.id[p_idx][c_idx])
								== copp_id) {
				if (copp_idx != NULL)
					*copp_idx = c_idx;
				if (port_idx != NULL)
					*port_idx = p_idx;
				return 0;
			}
		}
	}
	return -EINVAL;
}

static int adm_get_copp_id(int port_idx, int copp_idx)
{
	pr_debug("%s: port_idx:%d copp_idx:%d\n", __func__, port_idx, copp_idx);

	if (copp_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT) {
		pr_err("%s: Invalid copp_num: %d\n", __func__, copp_idx);
		return -EINVAL;
	}
	return atomic_read(&this_adm.copp.id[port_idx][copp_idx]);
}

static int adm_get_idx_if_single_copp_exists(int port_idx,
			int topology, int mode,
			int rate, int bit_width,
			u32 copp_token)
{
	int idx;

	pr_debug("%s: copp_token %d\n", __func__, copp_token);

	for (idx = 0; idx < MAX_COPPS_PER_PORT; idx++)
		if ((topology ==
			atomic_read(&this_adm.copp.topology[port_idx][idx])) &&
			(mode ==
			 atomic_read(&this_adm.copp.mode[port_idx][idx])) &&
			(rate ==
			 atomic_read(&this_adm.copp.rate[port_idx][idx])) &&
			(bit_width ==
			atomic_read(&this_adm.copp.bit_width[port_idx][idx])) &&
			(copp_token ==
			atomic_read(&this_adm.copp.token[port_idx][idx])))
			return idx;
	return -EINVAL;
}

static int adm_get_idx_if_copp_exists(int port_idx, int topology, int mode,
				 int rate, int bit_width, int app_type,
				 u32 copp_token)
{
	int idx;

	pr_debug("%s: port_idx-%d, topology-0x%x, mode-%d, rate-%d, bit_width-%d\n",
		 __func__, port_idx, topology, mode, rate, bit_width);

	if (copp_token)
		return adm_get_idx_if_single_copp_exists(port_idx,
				topology, mode,
				rate, bit_width,
				copp_token);

	for (idx = 0; idx < MAX_COPPS_PER_PORT; idx++)
		if ((topology ==
			atomic_read(&this_adm.copp.topology[port_idx][idx])) &&
		    (mode == atomic_read(&this_adm.copp.mode[port_idx][idx])) &&
		    (rate == atomic_read(&this_adm.copp.rate[port_idx][idx])) &&
		    (bit_width ==
			atomic_read(&this_adm.copp.bit_width[port_idx][idx])) &&
		    (app_type ==
			atomic_read(&this_adm.copp.app_type[port_idx][idx])))
			return idx;
	return -EINVAL;
}

static int adm_get_next_available_copp(int port_idx)
{
	int idx;

	pr_debug("%s:\n", __func__);
	for (idx = 0; idx < MAX_COPPS_PER_PORT; idx++) {
		pr_debug("%s: copp_id:0x%x port_idx:%d idx:%d\n", __func__,
			 atomic_read(&this_adm.copp.id[port_idx][idx]),
			 port_idx, idx);
		if (atomic_read(&this_adm.copp.id[port_idx][idx]) ==
								RESET_COPP_ID)
			break;
	}
	return idx;
}

static int adm_get_svc_version(uint32_t service_id)
{
	int ret = 0;
	static int adm_cached_version;
	size_t ver_size;
	struct avcs_fwk_ver_info *ver_info = NULL;

	if (service_id == AVCS_SERVICE_ID_ALL) {
		pr_err("%s: Invalid service id: %d", __func__,
					AVCS_SERVICE_ID_ALL);
		return -EINVAL;
	}

	if (adm_cached_version != 0)
		return adm_cached_version;

	ver_size = sizeof(struct avcs_get_fwk_version) +
			sizeof(struct avs_svc_api_info);
	ver_info = kzalloc(ver_size, GFP_KERNEL);
	if (ver_info == NULL)
		return -ENOMEM;

	ret = q6core_get_service_version(service_id, ver_info, ver_size);
	if (ret < 0)
		goto done;

	ret = ver_info->services[0].api_version;
	adm_cached_version = ret;
done:
	kfree(ver_info);
	return ret;
}
int srs_trumedia_open(int port_id, int copp_idx, __s32 srs_tech_id,
		      void *srs_params)
{
	struct param_hdr_v3 param_hdr = {0};
	struct mem_mapping_hdr mem_hdr = {0};
	u32 total_param_size = 0;
	bool outband = false;
	int port_idx;
	int ret = 0;

	pr_debug("SRS - %s", __func__);

	port_id = afe_convert_virtual_to_portid(port_id);
	port_idx = adm_validate_and_get_port_index(port_id);
	if (port_idx < 0) {
		pr_err("%s: Invalid port_id %#x\n", __func__, port_id);
		return -EINVAL;
	}

	param_hdr.module_id = SRS_TRUMEDIA_MODULE_ID;
	param_hdr.instance_id = INSTANCE_ID_0;

	switch (srs_tech_id) {
	case SRS_ID_GLOBAL: {
		param_hdr.param_id = SRS_TRUMEDIA_PARAMS;
		param_hdr.param_size =
			sizeof(struct srs_trumedia_params_GLOBAL);
		break;
	}
	case SRS_ID_WOWHD: {
		param_hdr.param_id = SRS_TRUMEDIA_PARAMS_WOWHD;
		param_hdr.param_size = sizeof(struct srs_trumedia_params_WOWHD);
		break;
	}
	case SRS_ID_CSHP: {
		param_hdr.param_id = SRS_TRUMEDIA_PARAMS_CSHP;
		param_hdr.param_size = sizeof(struct srs_trumedia_params_CSHP);
		break;
	}
	case SRS_ID_HPF: {
		param_hdr.param_id = SRS_TRUMEDIA_PARAMS_HPF;
		param_hdr.param_size = sizeof(struct srs_trumedia_params_HPF);
		break;
	}
	case SRS_ID_AEQ: {
		u8 *update_params_ptr = (u8 *) this_adm.outband_memmap.kvaddr;

		outband = true;

		if (update_params_ptr == NULL) {
			pr_err("ADM_SRS_TRUMEDIA - %s: null memmap for AEQ params\n",
				__func__);
			ret = -EINVAL;
			goto fail_cmd;
		}

		param_hdr.param_id = SRS_TRUMEDIA_PARAMS_AEQ;
		param_hdr.param_size = sizeof(struct srs_trumedia_params_AEQ);

		ret = q6common_pack_pp_params(update_params_ptr, &param_hdr,
					      srs_params, &total_param_size);
		if (ret) {
			pr_err("%s: Failed to pack param header and data, error %d\n",
			       __func__, ret);
			goto fail_cmd;
		}
		break;
	}
	case SRS_ID_HL: {
		param_hdr.param_id = SRS_TRUMEDIA_PARAMS_HL;
		param_hdr.param_size = sizeof(struct srs_trumedia_params_HL);
		break;
	}
	case SRS_ID_GEQ: {
		param_hdr.param_id = SRS_TRUMEDIA_PARAMS_GEQ;
		param_hdr.param_size = sizeof(struct srs_trumedia_params_GEQ);
		break;
	}
	default:
		goto fail_cmd;
	}

	if (outband && this_adm.outband_memmap.paddr) {
		mem_hdr.data_payload_addr_lsw =
			lower_32_bits(this_adm.outband_memmap.paddr);
		mem_hdr.data_payload_addr_msw =
			msm_audio_populate_upper_32_bits(
				this_adm.outband_memmap.paddr);
		mem_hdr.mem_map_handle = atomic_read(
			&this_adm.mem_map_handles[ADM_SRS_TRUMEDIA]);

		ret = adm_set_pp_params(port_id, copp_idx, &mem_hdr, NULL,
					total_param_size);
	} else {
		ret = adm_pack_and_set_one_pp_param(port_id, copp_idx,
						    param_hdr,
						    (u8 *) srs_params);
	}

	if (ret < 0)
		pr_err("SRS - %s: ADM enable for port %d failed\n", __func__,
			port_id);

fail_cmd:
	return ret;
}

static int adm_populate_channel_weight(u16 *ptr,
					struct msm_pcm_channel_mixer *ch_mixer,
					int channel_index)
{
	u16 i, j, start_index = 0;

	if (channel_index > ch_mixer->output_channel) {
		pr_err("%s: channel index %d is larger than output_channel %d\n",
			 __func__, channel_index, ch_mixer->output_channel);
		return -EINVAL;
	}

	for (i = 0; i < ch_mixer->output_channel; i++) {
		pr_debug("%s: weight for output %d:", __func__, i);
		for (j = 0; j < ADM_MAX_CHANNELS; j++)
			pr_debug(" %d",
				ch_mixer->channel_weight[i][j]);
		pr_debug("\n");
	}

	for (i = 0; i < channel_index; ++i)
		start_index += ch_mixer->input_channels[i];

	for (i = 0; i < ch_mixer->output_channel; ++i) {
		for (j = start_index;
			j < start_index +
			ch_mixer->input_channels[channel_index]; j++) {
			*ptr = ch_mixer->channel_weight[i][j];
			 pr_debug("%s: ptr[%d][%d] = %d\n",
				__func__, i, j, *ptr);
			 ptr++;
		}
	}

	return 0;
}

/*
 * adm_programable_channel_mixer
 *
 * Receives port_id, copp_idx, session_id, session_type, ch_mixer
 * and channel_index to send ADM command to mix COPP data.
 *
 * port_id - Passed value, port_id for which backend is wanted
 * copp_idx - Passed value, copp_idx for which COPP is wanted
 * session_id - Passed value, session_id for which session is needed
 * session_type - Passed value, session_type for RX or TX
 * ch_mixer - Passed value, ch_mixer for which channel mixer config is needed
 * channel_index - Passed value, channel_index for which channel is needed
 */
int adm_programable_channel_mixer(int port_id, int copp_idx, int session_id,
				  int session_type,
				  struct msm_pcm_channel_mixer *ch_mixer,
				  int channel_index)
{
	struct adm_cmd_set_pspd_mtmx_strtr_params_v5 *adm_params = NULL;
	struct param_hdr_v1 data_v5 = {0,};
	int ret = 0, port_idx, sz = 0, param_size = 0;
	u16 *adm_pspd_params;
	u16 *ptr;
	int index = 0;

	pr_debug("%s: port_id = %d\n", __func__, port_id);
	port_id = afe_convert_virtual_to_portid(port_id);
	port_idx = adm_validate_and_get_port_index(port_id);
	if (port_idx < 0) {
		pr_err("%s: Invalid port_id %#x\n", __func__, port_id);
		return -EINVAL;
	}
	/*
	 * First 8 bytes are 4 bytes as rule number, 2 bytes as output
	 * channel and 2 bytes as input channel.
	 * 2 * ch_mixer->output_channel means output channel mapping.
	 * 2 * ch_mixer->input_channels[channel_index]) means input
	 * channel mapping.
	 * 2 * ch_mixer->input_channels[channel_index] *
	 * ch_mixer->output_channel) means the channel mixer weighting
	 * coefficients.
	 * param_size needs to be a multiple of 4 bytes.
	 */

	param_size = 2 * (4 + ch_mixer->output_channel +
			ch_mixer->input_channels[channel_index] +
			ch_mixer->input_channels[channel_index] *
			ch_mixer->output_channel);
	param_size = roundup(param_size, 4);

	sz = sizeof(struct adm_cmd_set_pspd_mtmx_strtr_params_v5) +
	     sizeof(struct default_chmixer_param_id_coeff) +
	     sizeof(struct param_hdr_v3) + param_size;
	pr_debug("%s: sz = %d\n", __func__, sz);
	adm_params = kzalloc(sz, GFP_KERNEL);
	if (!adm_params)
		return -ENOMEM;

	adm_params->payload_addr_lsw = 0;
	adm_params->payload_addr_msw = 0;
	adm_params->mem_map_handle = 0;
	adm_params->direction = session_type;
	adm_params->sessionid = session_id;
	pr_debug("%s: copp_id = %d, session id  %d\n", __func__,
		atomic_read(&this_adm.copp.id[port_idx][copp_idx]),
			session_id);
	adm_params->deviceid = atomic_read(
				&this_adm.copp.id[port_idx][copp_idx]);
	adm_params->reserved = 0;

	data_v5.module_id = MTMX_MODULE_ID_DEFAULT_CHMIXER;
	data_v5.param_id =  DEFAULT_CHMIXER_PARAM_ID_COEFF;
	data_v5.reserved = 0;
	data_v5.param_size = param_size;
	adm_params->payload_size =
		sizeof(struct default_chmixer_param_id_coeff) +
		sizeof(struct param_hdr_v1) + data_v5.param_size;
	adm_pspd_params = (u16 *)((u8 *)adm_params +
			sizeof(struct adm_cmd_set_pspd_mtmx_strtr_params_v5));
	memcpy(adm_pspd_params, &data_v5, sizeof(data_v5));

	adm_pspd_params = (u16 *)((u8 *)adm_params +
			sizeof(struct adm_cmd_set_pspd_mtmx_strtr_params_v5)
			+ sizeof(data_v5));

	adm_pspd_params[0] = ch_mixer->rule;
	adm_pspd_params[2] = ch_mixer->output_channel;
	adm_pspd_params[3] = ch_mixer->input_channels[channel_index];
	index = 4;

	if (ch_mixer->override_cfg) {
		memcpy(&adm_pspd_params[index], &ch_mixer->out_ch_map,
			ch_mixer->output_channel * sizeof(uint16_t));
	} else {
		if (ch_mixer->output_channel == 1) {
			adm_pspd_params[index] = PCM_CHANNEL_FC;
		} else if (ch_mixer->output_channel == 2) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
		} else if (ch_mixer->output_channel == 3) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
			adm_pspd_params[index + 2] = PCM_CHANNEL_FC;
		} else if (ch_mixer->output_channel == 4) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
			adm_pspd_params[index + 2] = PCM_CHANNEL_LS;
			adm_pspd_params[index + 3] = PCM_CHANNEL_RS;
		} else if (ch_mixer->output_channel == 5) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
			adm_pspd_params[index + 2] = PCM_CHANNEL_FC;
			adm_pspd_params[index + 3] = PCM_CHANNEL_LS;
			adm_pspd_params[index + 4] = PCM_CHANNEL_RS;
		} else if (ch_mixer->output_channel == 6) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
			adm_pspd_params[index + 2] = PCM_CHANNEL_LFE;
			adm_pspd_params[index + 3] = PCM_CHANNEL_FC;
			adm_pspd_params[index + 4] = PCM_CHANNEL_LS;
			adm_pspd_params[index + 5] = PCM_CHANNEL_RS;
		} else if (ch_mixer->output_channel == 8) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
			adm_pspd_params[index + 2] = PCM_CHANNEL_LFE;
			adm_pspd_params[index + 3] = PCM_CHANNEL_FC;
			adm_pspd_params[index + 4] = PCM_CHANNEL_LS;
			adm_pspd_params[index + 5] = PCM_CHANNEL_RS;
			adm_pspd_params[index + 6] = PCM_CHANNEL_LB;
			adm_pspd_params[index + 7] = PCM_CHANNEL_RB;
		}
	}

	index = index + ch_mixer->output_channel;
	if (ch_mixer->override_cfg) {
		memcpy(&adm_pspd_params[index], &ch_mixer->in_ch_map,
			ch_mixer->input_channel * sizeof(uint16_t));
	} else {
		if (ch_mixer->input_channels[channel_index] == 1) {
			adm_pspd_params[index] = PCM_CHANNEL_FC;
		} else if (ch_mixer->input_channels[channel_index] == 2) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
		} else if (ch_mixer->input_channels[channel_index] == 3) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
			adm_pspd_params[index + 2] = PCM_CHANNEL_FC;
		} else if (ch_mixer->input_channels[channel_index] == 4) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
			adm_pspd_params[index + 2] = PCM_CHANNEL_LS;
			adm_pspd_params[index + 3] = PCM_CHANNEL_RS;
		} else if (ch_mixer->input_channels[channel_index] == 5) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
			adm_pspd_params[index + 2] = PCM_CHANNEL_FC;
			adm_pspd_params[index + 3] = PCM_CHANNEL_LS;
			adm_pspd_params[index + 4] = PCM_CHANNEL_RS;
		} else if (ch_mixer->input_channels[channel_index] == 6) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
			adm_pspd_params[index + 2] = PCM_CHANNEL_LFE;
			adm_pspd_params[index + 3] = PCM_CHANNEL_FC;
			adm_pspd_params[index + 4] = PCM_CHANNEL_LS;
			adm_pspd_params[index + 5] = PCM_CHANNEL_RS;
		} else if (ch_mixer->input_channels[channel_index] == 8) {
			adm_pspd_params[index] = PCM_CHANNEL_FL;
			adm_pspd_params[index + 1] = PCM_CHANNEL_FR;
			adm_pspd_params[index + 2] = PCM_CHANNEL_LFE;
			adm_pspd_params[index + 3] = PCM_CHANNEL_FC;
			adm_pspd_params[index + 4] = PCM_CHANNEL_LS;
			adm_pspd_params[index + 5] = PCM_CHANNEL_RS;
			adm_pspd_params[index + 6] = PCM_CHANNEL_LB;
			adm_pspd_params[index + 7] = PCM_CHANNEL_RB;
		}
	}

	index = index + ch_mixer->input_channels[channel_index];
	ret = adm_populate_channel_weight(&adm_pspd_params[index],
					ch_mixer, channel_index);
	if (ret) {
		pr_err("%s: fail to get channel weight with error %d\n",
			__func__, ret);
		goto fail_cmd;
	}

	adm_params->hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
				APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
	adm_params->hdr.src_svc = APR_SVC_ADM;
	adm_params->hdr.src_domain = APR_DOMAIN_APPS;
	adm_params->hdr.src_port = port_id;
	adm_params->hdr.dest_svc = APR_SVC_ADM;
	adm_params->hdr.dest_domain = APR_DOMAIN_ADSP;
	adm_params->hdr.dest_port =
			atomic_read(&this_adm.copp.id[port_idx][copp_idx]);
	adm_params->hdr.token = port_idx << 16 | copp_idx;
	adm_params->hdr.opcode = ADM_CMD_SET_PSPD_MTMX_STRTR_PARAMS_V5;
	adm_params->hdr.pkt_size = sz;
	adm_params->payload_addr_lsw = 0;
	adm_params->payload_addr_msw = 0;
	adm_params->mem_map_handle = 0;
	adm_params->reserved = 0;

	ptr = (u16 *)adm_params;
	for (index = 0; index < (sz / 2); index++)
		pr_debug("%s: adm_params[%d] = 0x%x\n",
			__func__, index, (unsigned int)ptr[index]);

	atomic_set(&this_adm.copp.stat[port_idx][copp_idx], 0);
	ret = apr_send_pkt(this_adm.apr, (uint32_t *)adm_params);
	if (ret < 0) {
		pr_err("%s: Set params failed port %d rc %d\n", __func__,
			port_id, ret);
		ret = -EINVAL;
		goto fail_cmd;
	}

	ret = wait_event_timeout(this_adm.copp.wait[port_idx][copp_idx],
			atomic_read(
			&this_adm.copp.stat[port_idx][copp_idx]) >= 0,
			msecs_to_jiffies(TIMEOUT_MS));
	if (!ret) {
		pr_err("%s: set params timed out port = %d\n",
			__func__, port_id);
		ret = -ETIMEDOUT;
		goto fail_cmd;
	}
	ret = 0;
fail_cmd:
	kfree(adm_params);

	return ret;
}

int adm_set_pspd_matrix_params(int port_id, int copp_idx,
				unsigned int session_id, char *params,
				uint32_t params_length,
				int session_type)
{
	struct adm_cmd_set_pspd_mtmx_strtr_params_v5 *adm_params = NULL;
	int sz, rc = 0, port_idx;

	pr_debug("%s:\n", __func__);
	port_id = afe_convert_virtual_to_portid(port_id);
	port_idx = adm_validate_and_get_port_index(port_id);
	if (port_idx < 0) {
		pr_err("%s: Invalid port_id 0x%x\n", __func__, port_id);
		return -EINVAL;
	}

	sz = sizeof(struct adm_cmd_set_pspd_mtmx_strtr_params_v5) +
		params_length;
	adm_params = kzalloc(sz, GFP_KERNEL);
	if (!adm_params) {
		pr_err("%s, adm params memory alloc failed\n", __func__);
		return -ENOMEM;
	}

	memcpy(((u8 *)adm_params +
		sizeof(struct adm_cmd_set_pspd_mtmx_strtr_params_v5)),
		params, params_length);
	adm_params->hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
					APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
	adm_params->hdr.pkt_size = sz;
	adm_params->hdr.src_svc = APR_SVC_ADM;
	adm_params->hdr.src_domain = APR_DOMAIN_APPS;
	adm_params->hdr.src_port = port_id;
	adm_params->hdr.dest_svc = APR_SVC_ADM;
	adm_params->hdr.dest_domain = APR_DOMAIN_ADSP;
	adm_params->hdr.dest_port = 0; /* Ignored */;
	adm_params->hdr.token = port_idx << 16 | copp_idx;
	adm_params->hdr.opcode = ADM_CMD_SET_PSPD_MTMX_STRTR_PARAMS_V5;
	adm_params->payload_addr_lsw = 0;
	adm_params->payload_addr_msw = 0;
	adm_params->mem_map_handle = 0;
	adm_params->payload_size = params_length;
	/* direction RX as 0 */
	adm_params->direction = session_type;
	/* session id for this cmd to be applied on */
	adm_params->sessionid = session_id;
	adm_params->deviceid =
			atomic_read(&this_adm.copp.id[port_idx][copp_idx]);
	adm_params->reserved = 0;
	pr_debug("%s: deviceid %d, session_id %d, src_port %d, dest_port %d\n",
		__func__, adm_params->deviceid, adm_params->sessionid,
		adm_params->hdr.src_port, adm_params->hdr.dest_port);
	atomic_set(&this_adm.copp.stat[port_idx][copp_idx], -1);
	rc = apr_send_pkt(this_adm.apr, (uint32_t *)adm_params);
	if (rc < 0) {
		pr_err("%s: Set params failed port = 0x%x rc %d\n",
			__func__, port_id, rc);
		rc = -EINVAL;
		goto set_stereo_to_custom_stereo_return;
	}
	/* Wait for the callback */
	rc = wait_event_timeout(this_adm.copp.wait[port_idx][copp_idx],
				atomic_read(&this_adm.copp.stat
				[port_idx][copp_idx]) >= 0,
				msecs_to_jiffies(TIMEOUT_MS));
	if (!rc) {
		pr_err("%s: Set params timed out port = 0x%x\n", __func__,
			port_id);
		rc = -EINVAL;
		goto set_stereo_to_custom_stereo_return;
	} else if (atomic_read(&this_adm.copp.stat
				[port_idx][copp_idx]) > 0) {
		pr_err("%s: DSP returned error[%s]\n", __func__,
			adsp_err_get_err_str(atomic_read(
			&this_adm.copp.stat
			[port_idx][copp_idx])));
		rc = adsp_err_get_lnx_err_code(
				atomic_read(&this_adm.copp.stat
					[port_idx][copp_idx]));
		goto set_stereo_to_custom_stereo_return;
	}
	rc = 0;
set_stereo_to_custom_stereo_return:
	kfree(adm_params);
	return rc;
}

/*
 * With pre-packed data, only the opcode differes from V5 and V6.
 * Use q6common_pack_pp_params to pack the data correctly.
 */
int adm_set_pp_params(int port_id, int copp_idx,
		      struct mem_mapping_hdr *mem_hdr, u8 *param_data,
		      u32 param_size)
{
	struct adm_cmd_set_pp_params *adm_set_params = NULL;
	int size = sizeof(struct adm_cmd_set_pp_params);
	int port_idx = 0;
	atomic_t *copp_stat = NULL;
	int ret = 0;

	port_id = afe_convert_virtual_to_portid(port_id);
	port_idx = adm_validate_and_get_port_index(port_id);
	if (port_idx < 0 || port_idx >= AFE_MAX_PORTS) {
		pr_err("%s: Invalid port_idx 0x%x\n", __func__, port_idx);
		return -EINVAL;
	} else if (copp_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT) {
		pr_err("%s: Invalid copp_idx 0x%x\n", __func__, copp_idx);
		return -EINVAL;
	}

	/* Only add params_size in inband case */
	if (param_data != NULL)
		size += param_size;
	adm_set_params = kzalloc(size, GFP_KERNEL);
	if (!adm_set_params)
		return -ENOMEM;

	adm_set_params->apr_hdr.hdr_field =
		APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD, APR_HDR_LEN(APR_HDR_SIZE),
			      APR_PKT_VER);
	adm_set_params->apr_hdr.pkt_size = size;
	adm_set_params->apr_hdr.src_svc = APR_SVC_ADM;
	adm_set_params->apr_hdr.src_domain = APR_DOMAIN_APPS;
	adm_set_params->apr_hdr.src_port = port_id;
	adm_set_params->apr_hdr.dest_svc = APR_SVC_ADM;
	adm_set_params->apr_hdr.dest_domain = APR_DOMAIN_ADSP;
	adm_set_params->apr_hdr.dest_port =
		atomic_read(&this_adm.copp.id[port_idx][copp_idx]);
	adm_set_params->apr_hdr.token = port_idx << 16 | copp_idx;

	if (q6common_is_instance_id_supported())
		adm_set_params->apr_hdr.opcode = ADM_CMD_SET_PP_PARAMS_V6;
	else
		adm_set_params->apr_hdr.opcode = ADM_CMD_SET_PP_PARAMS_V5;

	adm_set_params->payload_size = param_size;

	if (mem_hdr != NULL) {
		/* Out of Band Case */
		adm_set_params->mem_hdr = *mem_hdr;
	} else if (param_data != NULL) {
		/* In band case. Parameter data must be pre-packed with its
		 * header before calling this function. Use
		 * q6common_pack_pp_params to pack parameter data and header
		 * correctly.
		 */
		memcpy(&adm_set_params->param_data, param_data, param_size);
	} else {
		pr_err("%s: Received NULL pointers for both memory header and param data\n",
		       __func__);
		ret = -EINVAL;
		goto done;
	}

	copp_stat = &this_adm.copp.stat[port_idx][copp_idx];
	atomic_set(copp_stat, -1);
	ret = apr_send_pkt(this_adm.apr, (uint32_t *) adm_set_params);
	if (ret < 0) {
		pr_err("%s: Set params APR send failed port = 0x%x ret %d\n",
		       __func__, port_id, ret);
		goto done;
	}
	ret = wait_event_timeout(this_adm.copp.wait[port_idx][copp_idx],
				 atomic_read(copp_stat) >= 0,
				 msecs_to_jiffies(TIMEOUT_MS));
	if (!ret) {
		pr_err("%s: Set params timed out port = 0x%x\n", __func__,
		       port_id);
		ret = -ETIMEDOUT;
		goto done;
	}
	if (atomic_read(copp_stat) > 0) {
		pr_err("%s: DSP returned error[%s]\n", __func__,
		       adsp_err_get_err_str(atomic_read(copp_stat)));
		ret = adsp_err_get_lnx_err_code(atomic_read(copp_stat));
		goto done;
	}

	ret = 0;
done:
	kfree(adm_set_params);
	return ret;
}
EXPORT_SYMBOL(adm_set_pp_params);

int adm_pack_and_set_one_pp_param(int port_id, int copp_idx,
				  struct param_hdr_v3 param_hdr, u8 *param_data)
{
	u8 *packed_data = NULL;
	u32 total_size = 0;
	int ret = 0;

	total_size = sizeof(union param_hdrs) + param_hdr.param_size;
	packed_data = kzalloc(total_size, GFP_KERNEL);
	if (!packed_data)
		return -ENOMEM;

	ret = q6common_pack_pp_params(packed_data, &param_hdr, param_data,
				      &total_size);
	if (ret) {
		pr_err("%s: Failed to pack parameter data, error %d\n",
		       __func__, ret);
		goto done;
	}

	ret = adm_set_pp_params(port_id, copp_idx, NULL, packed_data,
				total_size);
	if (ret)
		pr_err("%s: Failed to set parameter data, error %d\n", __func__,
		       ret);
done:
	kfree(packed_data);
	return ret;
}
EXPORT_SYMBOL(adm_pack_and_set_one_pp_param);

/*
 * Only one parameter can be requested at a time. Therefore, packing and sending
 * the request can be handled locally.
 */
int adm_get_pp_params(int port_id, int copp_idx, uint32_t client_id,
		      struct mem_mapping_hdr *mem_hdr,
		      struct param_hdr_v3 *param_hdr, u8 *returned_param_data)
{
	struct adm_cmd_get_pp_params adm_get_params;
	int total_size = 0;
	int get_param_array_sz = ARRAY_SIZE(adm_get_parameters);
	int returned_param_size = 0;
	int returned_param_size_in_bytes = 0;
	int port_idx = 0;
	int idx = 0;
	atomic_t *copp_stat = NULL;
	int ret = 0;

	if (param_hdr == NULL) {
		pr_err("%s: Received NULL pointer for parameter header\n",
		       __func__);
		return -EINVAL;
	}

	port_id = afe_convert_virtual_to_portid(port_id);
	port_idx = adm_validate_and_get_port_index(port_id);
	if (port_idx < 0 || port_idx >= AFE_MAX_PORTS) {
		pr_err("%s: Invalid port_idx 0x%x\n", __func__, port_idx);
		return -EINVAL;
	}
	if (copp_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT) {
		pr_err("%s: Invalid copp_idx 0x%x\n", __func__, copp_idx);
		return -EINVAL;
	}

	memset(&adm_get_params, 0, sizeof(adm_get_params));

	if (mem_hdr != NULL)
		adm_get_params.mem_hdr = *mem_hdr;

	q6common_pack_pp_params((u8 *) &adm_get_params.param_hdr, param_hdr,
				NULL, &total_size);

	/* Pack APR header after filling body so total_size has correct value */
	adm_get_params.apr_hdr.pkt_size = total_size;
	adm_get_params.apr_hdr.src_svc = APR_SVC_ADM;
	adm_get_params.apr_hdr.src_domain = APR_DOMAIN_APPS;
	adm_get_params.apr_hdr.src_port = port_id;
	adm_get_params.apr_hdr.dest_svc = APR_SVC_ADM;
	adm_get_params.apr_hdr.dest_domain = APR_DOMAIN_ADSP;
	adm_get_params.apr_hdr.dest_port =
		atomic_read(&this_adm.copp.id[port_idx][copp_idx]);
	adm_get_params.apr_hdr.token =
		port_idx << 16 | client_id << 8 | copp_idx;

	if (q6common_is_instance_id_supported())
		adm_get_params.apr_hdr.opcode = ADM_CMD_GET_PP_PARAMS_V6;
	else
		adm_get_params.apr_hdr.opcode = ADM_CMD_GET_PP_PARAMS_V5;

	copp_stat = &this_adm.copp.stat[port_idx][copp_idx];
	atomic_set(copp_stat, -1);
	ret = apr_send_pkt(this_adm.apr, (uint32_t *) &adm_get_params);
	if (ret < 0) {
		pr_err("%s: Get params APR send failed port = 0x%x ret %d\n",
		       __func__, port_id, ret);
		ret = -EINVAL;
		goto done;
	}
	ret = wait_event_timeout(this_adm.copp.wait[port_idx][copp_idx],
				 atomic_read(copp_stat) >= 0,
				 msecs_to_jiffies(TIMEOUT_MS));
	if (!ret) {
		pr_err("%s: Get params timed out port = 0x%x\n", __func__,
		       port_id);
		ret = -ETIMEDOUT;
		goto done;
	}
	if (atomic_read(copp_stat) > 0) {
		pr_err("%s: DSP returned error[%s]\n", __func__,
		       adsp_err_get_err_str(atomic_read(copp_stat)));
		ret = adsp_err_get_lnx_err_code(atomic_read(copp_stat));
		goto done;
	}

	ret = 0;

	/* Copy data to caller if sent in band */
	if (!returned_param_data) {
		pr_debug("%s: Received NULL pointer for param destination, not copying payload\n",
			__func__);
		return 0;
	}

	idx = ADM_GET_PARAMETER_LENGTH * copp_idx;
	returned_param_size = adm_get_parameters[idx];
	if (returned_param_size < 0 ||
	    returned_param_size + idx + 1 > get_param_array_sz) {
		pr_err("%s: Invalid parameter size %d\n", __func__,
		       returned_param_size);
		return -EINVAL;
	}

	returned_param_size_in_bytes = returned_param_size * sizeof(uint32_t);
	if (param_hdr->param_size < returned_param_size_in_bytes) {
		pr_err("%s: Provided buffer is not big enough, provided buffer size(%d) size needed(%d)\n",
		       __func__, param_hdr->param_size,
		       returned_param_size_in_bytes);
		return -EINVAL;
	}

	memcpy(returned_param_data, &adm_get_parameters[idx + 1],
	       returned_param_size_in_bytes);
done:
	return ret;
}
EXPORT_SYMBOL(adm_get_pp_params);

int adm_get_pp_topo_module_list_v2(int port_id, int copp_idx,
				   int32_t param_length,
				   int32_t *returned_params)
{
	struct adm_cmd_get_pp_topo_module_list adm_get_module_list;
	bool iid_supported = q6common_is_instance_id_supported();
	int *topo_list;
	int num_modules = 0;
	int list_size = 0;
	int port_idx, idx;
	int i = 0;
	atomic_t *copp_stat = NULL;
	int ret = 0;

	pr_debug("%s : port_id %x", __func__, port_id);
	port_id = afe_convert_virtual_to_portid(port_id);
	port_idx = adm_validate_and_get_port_index(port_id);
	if (port_idx < 0) {
		pr_err("%s: Invalid port_id 0x%x\n", __func__, port_id);
		return -EINVAL;
	}
	if (copp_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT) {
		pr_err("%s: Invalid copp_num: %d\n", __func__, copp_idx);
		return -EINVAL;
	}

	memset(&adm_get_module_list, 0, sizeof(adm_get_module_list));

	adm_get_module_list.apr_hdr.pkt_size = sizeof(adm_get_module_list);
	adm_get_module_list.apr_hdr.src_svc = APR_SVC_ADM;
	adm_get_module_list.apr_hdr.src_domain = APR_DOMAIN_APPS;
	adm_get_module_list.apr_hdr.src_port = port_id;
	adm_get_module_list.apr_hdr.dest_svc = APR_SVC_ADM;
	adm_get_module_list.apr_hdr.dest_domain = APR_DOMAIN_ADSP;
	adm_get_module_list.apr_hdr.dest_port =
		atomic_read(&this_adm.copp.id[port_idx][copp_idx]);
	adm_get_module_list.apr_hdr.token = port_idx << 16 | copp_idx;
	/*
	 * Out of band functionality is not currently utilized.
	 * Assume in band.
	 */
	if (iid_supported) {
		adm_get_module_list.apr_hdr.opcode =
			ADM_CMD_GET_PP_TOPO_MODULE_LIST_V2;
		adm_get_module_list.param_max_size = param_length;
	} else {
		adm_get_module_list.apr_hdr.opcode =
			ADM_CMD_GET_PP_TOPO_MODULE_LIST;

		if (param_length > U16_MAX) {
			pr_err("%s: Invalid param length for V1 %d\n", __func__,
			       param_length);
			return -EINVAL;
		}
		adm_get_module_list.param_max_size = param_length << 16;
	}

	copp_stat = &this_adm.copp.stat[port_idx][copp_idx];
	atomic_set(copp_stat, -1);
	ret = apr_send_pkt(this_adm.apr, (uint32_t *) &adm_get_module_list);
	if (ret < 0) {
		pr_err("%s: APR send pkt failed for port_id: 0x%x failed ret %d\n",
		       __func__, port_id, ret);
		ret = -EINVAL;
		goto done;
	}
	ret = wait_event_timeout(this_adm.copp.wait[port_idx][copp_idx],
				 atomic_read(copp_stat) >= 0,
				 msecs_to_jiffies(TIMEOUT_MS));
	if (!ret) {
		pr_err("%s: Timeout for port_id: 0x%x\n", __func__, port_id);
		ret = -ETIMEDOUT;
		goto done;
	}
	if (atomic_read(copp_stat) > 0) {
		pr_err("%s: DSP returned error[%s]\n", __func__,
		       adsp_err_get_err_str(atomic_read(copp_stat)));
		ret = adsp_err_get_lnx_err_code(atomic_read(copp_stat));
		goto done;
	}

	ret = 0;

	if (returned_params) {
		/*
		 * When processing ADM_CMDRSP_GET_PP_TOPO_MODULE_LIST IID is
		 * added since it is not present. Therefore, there is no need to
		 * do anything different if IID is not supported here as it is
		 * already taken care of.
		 */
		idx = ADM_GET_TOPO_MODULE_INSTANCE_LIST_LENGTH * copp_idx;
		num_modules = adm_module_topo_list[idx];
		if (num_modules < 0 || num_modules > MAX_MODULES_IN_TOPO) {
			pr_err("%s: Invalid number of modules returned %d\n",
			       __func__, num_modules);
			return -EINVAL;
		}

		list_size = num_modules * sizeof(struct module_instance_info);
		if (param_length < list_size) {
			pr_err("%s: Provided buffer not big enough to hold module-instance list, provided size %d, needed size %d\n",
			       __func__, param_length, list_size);
			return -EINVAL;
		}

		topo_list = (int32_t *) (&adm_module_topo_list[idx]);
		memcpy(returned_params, topo_list, list_size);
		for (i = 1; i <= num_modules; i += 2) {
			pr_debug("module = 0x%x instance = 0x%x\n",
				 returned_params[i], returned_params[i + 1]);
		}
	}
done:
	return ret;
}
EXPORT_SYMBOL(adm_get_pp_topo_module_list_v2);

static void adm_callback_debug_print(struct apr_client_data *data)
{
	uint32_t *payload;
	payload = data->payload;

	if (data->payload_size >= 8)
		pr_debug("%s: code = 0x%x PL#0[0x%x], PL#1[0x%x], size = %d\n",
			__func__, data->opcode, payload[0], payload[1],
			data->payload_size);
	else if (data->payload_size >= 4)
		pr_debug("%s: code = 0x%x PL#0[0x%x], size = %d\n",
			__func__, data->opcode, payload[0],
			data->payload_size);
	else
		pr_debug("%s: code = 0x%x, size = %d\n",
			__func__, data->opcode, data->payload_size);
}

int adm_set_multi_ch_map(char *channel_map, int path)
{
	int idx;

	if (path == ADM_PATH_PLAYBACK) {
		idx = ADM_MCH_MAP_IDX_PLAYBACK;
	} else if (path == ADM_PATH_LIVE_REC) {
		idx = ADM_MCH_MAP_IDX_REC;
	} else {
		pr_err("%s: invalid attempt to set path %d\n", __func__, path);
		return -EINVAL;
	}

	memcpy(multi_ch_maps[idx].channel_mapping, channel_map,
		PCM_FORMAT_MAX_NUM_CHANNEL);
	multi_ch_maps[idx].set_channel_map = true;

	return 0;
}

int adm_get_multi_ch_map(char *channel_map, int path)
{
	int idx;

	if (path == ADM_PATH_PLAYBACK) {
		idx = ADM_MCH_MAP_IDX_PLAYBACK;
	} else if (path == ADM_PATH_LIVE_REC) {
		idx = ADM_MCH_MAP_IDX_REC;
	} else {
		pr_err("%s: invalid attempt to get path %d\n", __func__, path);
		return -EINVAL;
	}

	if (multi_ch_maps[idx].set_channel_map) {
		memcpy(channel_map, multi_ch_maps[idx].channel_mapping,
		       PCM_FORMAT_MAX_NUM_CHANNEL);
	}

	return 0;
}

static int adm_process_get_param_response(u32 opcode, u32 idx, u32 *payload,
					  u32 payload_size)
{
	struct adm_cmd_rsp_get_pp_params_v5 *v5_rsp = NULL;
	struct adm_cmd_rsp_get_pp_params_v6 *v6_rsp = NULL;
	u32 *param_data = NULL;
	int data_size;
	int struct_size;

	if (payload == NULL) {
		pr_err("%s: Payload is NULL\n", __func__);
		return -EINVAL;
	}

	switch (opcode) {
	case ADM_CMDRSP_GET_PP_PARAMS_V5:
		struct_size = sizeof(struct adm_cmd_rsp_get_pp_params_v5);
		v5_rsp = (struct adm_cmd_rsp_get_pp_params_v5 *) payload;
		data_size = v5_rsp->param_hdr.param_size;
		param_data = v5_rsp->param_data;
		break;
	case ADM_CMDRSP_GET_PP_PARAMS_V6:
		struct_size = sizeof(struct adm_cmd_rsp_get_pp_params_v6);
		v6_rsp = (struct adm_cmd_rsp_get_pp_params_v6 *) payload;
		data_size = v6_rsp->param_hdr.param_size;
		param_data = v6_rsp->param_data;
		break;
	default:
		pr_err("%s: Invalid opcode %d\n", __func__, opcode);
		return -EINVAL;
	}

	/*
	 * Just store the returned parameter data, not the header. The calling
	 * function is expected to know what it asked for. Therefore, there is
	 * no difference between V5 and V6.
	 */
	if ((payload_size >= struct_size + data_size) &&
	    (ARRAY_SIZE(adm_get_parameters) > idx) &&
	    (ARRAY_SIZE(adm_get_parameters) >= idx + 1 + data_size)) {
		/*
		 * data_size is expressed in number of bytes, store in number of
		 * ints
		 */
		adm_get_parameters[idx] =
			data_size / sizeof(*adm_get_parameters);
		pr_debug("%s: GET_PP PARAM: received parameter length: 0x%x\n",
			 __func__, adm_get_parameters[idx]);
		/* store params after param_size */
		memcpy(&adm_get_parameters[idx + 1], param_data, data_size);
		return 0;
	}

	pr_err("%s: Invlaid parameter combination, payload_size %d, idx %d\n",
	       __func__, payload_size, idx);
	return -EINVAL;
}

static int adm_process_get_topo_list_response(u32 opcode, int copp_idx,
					      u32 num_modules, u32 *payload,
					      u32 payload_size)
{
	u32 *fill_list = NULL;
	int idx = 0;
	int i = 0;
	int j = 0;

	if (payload == NULL) {
		pr_err("%s: Payload is NULL\n", __func__);
		return -EINVAL;
	} else if (copp_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT)
		pr_err("%s: Invalid COPP index %d\n", __func__, copp_idx);
	return -EINVAL;

	idx = ADM_GET_TOPO_MODULE_INSTANCE_LIST_LENGTH * copp_idx;
	fill_list = adm_module_topo_list + idx;
	*fill_list++ = num_modules;
	for (i = 0; i < num_modules; i++) {
		if (j > payload_size / sizeof(u32)) {
			pr_err("%s: Invalid number of modules specified %d\n",
			       __func__, num_modules);
			return -EINVAL;
		}

		/* store module ID */
		*fill_list++ = payload[j];
		j++;

		switch (opcode) {
		case ADM_CMDRSP_GET_PP_TOPO_MODULE_LIST_V2:
			/* store instance ID */
			*fill_list++ = payload[j];
			j++;
			break;
		case ADM_CMDRSP_GET_PP_TOPO_MODULE_LIST:
			/* Insert IID 0 when repacking */
			*fill_list++ = INSTANCE_ID_0;
			break;
		default:
			pr_err("%s: Invalid opcode %d\n", __func__, opcode);
			return -EINVAL;
		}
	}

	return 0;
}

static int32_t adm_callback(struct apr_client_data *data, void *priv)
{
	uint32_t *payload;
	int i, j, port_idx, copp_idx, idx, client_id;
	int num_modules;
	int ret;

	if (data == NULL) {
		pr_err("%s: data parameter is null\n", __func__);
		return -EINVAL;
	}

	payload = data->payload;

	if (data->opcode == RESET_EVENTS) {
		pr_debug("%s: Reset event is received: %d %d apr[%pK]\n",
			__func__,
			data->reset_event, data->reset_proc, this_adm.apr);
		if (this_adm.apr) {
			apr_reset(this_adm.apr);
			for (i = 0; i < AFE_MAX_PORTS; i++) {
				for (j = 0; j < MAX_COPPS_PER_PORT; j++) {
					atomic_set(&this_adm.copp.id[i][j],
						   RESET_COPP_ID);
					atomic_set(&this_adm.copp.cnt[i][j], 0);
					atomic_set(
						&this_adm.copp.topology[i][j],
						0);
					atomic_set(&this_adm.copp.mode[i][j],
						   0);
					atomic_set(&this_adm.copp.stat[i][j],
						   0);
					atomic_set(&this_adm.copp.rate[i][j],
						   0);
					atomic_set(
						&this_adm.copp.channels[i][j],
						0);
					atomic_set(
					    &this_adm.copp.bit_width[i][j], 0);
					atomic_set(
					    &this_adm.copp.app_type[i][j], 0);
					atomic_set(
					   &this_adm.copp.acdb_id[i][j], 0);
					this_adm.copp.adm_status[i][j] =
						ADM_STATUS_CALIBRATION_REQUIRED;
				}
			}
			this_adm.apr = NULL;
			cal_utils_clear_cal_block_q6maps(ADM_MAX_CAL_TYPES,
				this_adm.cal_data);
			mutex_lock(&this_adm.cal_data
				[ADM_CUSTOM_TOP_CAL]->lock);
			this_adm.set_custom_topology = 1;
			mutex_unlock(&this_adm.cal_data[
				ADM_CUSTOM_TOP_CAL]->lock);
			rtac_clear_mapping(ADM_RTAC_CAL);
			/*
			 * Free the ION memory and clear the map handles
			 * for Source Tracking
			 */
			if (this_adm.sourceTrackingData.memmap.paddr != 0) {
				msm_audio_ion_free(
					this_adm.sourceTrackingData.ion_client,
					this_adm.sourceTrackingData.ion_handle);
				this_adm.sourceTrackingData.ion_client = NULL;
				this_adm.sourceTrackingData.ion_handle = NULL;
				this_adm.sourceTrackingData.memmap.size = 0;
				this_adm.sourceTrackingData.memmap.kvaddr =
									 NULL;
				this_adm.sourceTrackingData.memmap.paddr = 0;
				this_adm.sourceTrackingData.apr_cmd_status = -1;
				atomic_set(&this_adm.mem_map_handles[
					ADM_MEM_MAP_INDEX_SOURCE_TRACKING], 0);
			}
		}
		return 0;
	}

	adm_callback_debug_print(data);
	if (data->payload_size) {
		copp_idx = (data->token) & 0XFF;
		port_idx = ((data->token) >> 16) & 0xFF;
		client_id = ((data->token) >> 8) & 0xFF;
		if (port_idx < 0 || port_idx >= AFE_MAX_PORTS) {
			pr_err("%s: Invalid port idx %d token %d\n",
				__func__, port_idx, data->token);
			return 0;
		}
		if (copp_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT) {
			pr_err("%s: Invalid copp idx %d token %d\n",
				__func__, copp_idx, data->token);
			return 0;
		}
		if (client_id < 0 || client_id >= ADM_CLIENT_ID_MAX) {
			pr_err("%s: Invalid client id %d\n", __func__,
				client_id);
			return 0;
		}
		if (data->opcode == APR_BASIC_RSP_RESULT) {
			pr_debug("%s: APR_BASIC_RSP_RESULT id 0x%x\n",
				__func__, payload[0]);
			if (payload[1] != 0) {
				pr_err("%s: cmd = 0x%x returned error = 0x%x\n",
					__func__, payload[0], payload[1]);
			}
			switch (payload[0]) {
			case ADM_CMD_SET_PP_PARAMS_V5:
			case ADM_CMD_SET_PP_PARAMS_V6:
				pr_debug("%s: ADM_CMD_SET_PP_PARAMS\n",
					 __func__);
				if (client_id == ADM_CLIENT_ID_SOURCE_TRACKING)
					this_adm.sourceTrackingData.
						apr_cmd_status = payload[1];
				else if (rtac_make_adm_callback(payload,
							data->payload_size))
					break;
				/*
				 * if soft volume is called and already
				 * interrupted break out of the sequence here
				 */
			case ADM_CMD_DEVICE_OPEN_V5:
			case ADM_CMD_DEVICE_CLOSE_V5:
			case ADM_CMD_DEVICE_OPEN_V6:
			case ADM_CMD_DEVICE_OPEN_V8:
			case ADM_CMD_SET_MTMX_STRTR_DEV_PARAMS_V1:
				pr_debug("%s: Basic callback received, wake up.\n",
					__func__);
				atomic_set(&this_adm.copp.stat[port_idx]
						[copp_idx], payload[1]);
				wake_up(
				&this_adm.copp.wait[port_idx][copp_idx]);
				break;
			case ADM_CMD_ADD_TOPOLOGIES:
				pr_debug("%s: callback received, ADM_CMD_ADD_TOPOLOGIES.\n",
					__func__);
				atomic_set(&this_adm.adm_stat, payload[1]);
				wake_up(&this_adm.adm_wait);
				break;
			case ADM_CMD_MATRIX_MAP_ROUTINGS_V5:
			case ADM_CMD_STREAM_DEVICE_MAP_ROUTINGS_V5:
				pr_debug("%s: Basic callback received, wake up.\n",
					__func__);
				atomic_set(&this_adm.matrix_map_stat,
					payload[1]);
				wake_up(&this_adm.matrix_map_wait);
				break;
			case ADM_CMD_SHARED_MEM_UNMAP_REGIONS:
				pr_debug("%s: ADM_CMD_SHARED_MEM_UNMAP_REGIONS\n",
					__func__);
				atomic_set(&this_adm.adm_stat, payload[1]);
				wake_up(&this_adm.adm_wait);
				break;
			case ADM_CMD_SHARED_MEM_MAP_REGIONS:
				pr_debug("%s: ADM_CMD_SHARED_MEM_MAP_REGIONS\n",
					__func__);
				/* Should only come here if there is an APR */
				/* error or malformed APR packet. Otherwise */
				/* response will be returned as */
				if (payload[1] != 0) {
					pr_err("%s: ADM map error, resuming\n",
						__func__);
					atomic_set(&this_adm.adm_stat,
						payload[1]);
					wake_up(&this_adm.adm_wait);
				}
				break;
			case ADM_CMD_GET_PP_PARAMS_V5:
			case ADM_CMD_GET_PP_PARAMS_V6:
				pr_debug("%s: ADM_CMD_GET_PP_PARAMS\n",
					 __func__);
				/* Should only come here if there is an APR */
				/* error or malformed APR packet. Otherwise */
				/* response will be returned as */
				/* ADM_CMDRSP_GET_PP_PARAMS_V5 */
				if (client_id ==
					ADM_CLIENT_ID_SOURCE_TRACKING) {
					this_adm.sourceTrackingData.
						apr_cmd_status = payload[1];
					if (payload[1] != 0)
						pr_err("%s: ADM get param error = %d\n",
							__func__, payload[1]);

					atomic_set(&this_adm.copp.stat
						[port_idx][copp_idx],
						payload[1]);
					wake_up(&this_adm.copp.wait
							[port_idx][copp_idx]);
				} else {
					if (payload[1] != 0) {
						pr_err("%s: ADM get param error = %d, resuming\n",
							__func__, payload[1]);

						rtac_make_adm_callback(payload,
							data->payload_size);
					}
				}
				break;
			case ADM_CMD_SET_PSPD_MTMX_STRTR_PARAMS_V5:
				pr_debug("%s: ADM_CMD_SET_PSPD_MTMX_STRTR_PARAMS_V5\n",
					__func__);
				atomic_set(&this_adm.copp.stat[port_idx]
						[copp_idx], payload[1]);
				wake_up(
				&this_adm.copp.wait[port_idx][copp_idx]);
				break;
			case ADM_CMD_GET_PP_TOPO_MODULE_LIST:
			case ADM_CMD_GET_PP_TOPO_MODULE_LIST_V2:
				pr_debug("%s:ADM_CMD_GET_PP_TOPO_MODULE_LIST\n",
					 __func__);
				if (payload[1] != 0)
					pr_err("%s: ADM get topo list error = %d\n",
					       __func__, payload[1]);
				break;
			default:
				pr_err("%s: Unknown Cmd: 0x%x\n", __func__,
								payload[0]);
				break;
			}
			return 0;
		}

		switch (data->opcode) {
		case ADM_CMDRSP_DEVICE_OPEN_V5:
		case ADM_CMDRSP_DEVICE_OPEN_V6:
		case ADM_CMDRSP_DEVICE_OPEN_V8: {
			struct adm_cmd_rsp_device_open_v5 *open =
			(struct adm_cmd_rsp_device_open_v5 *)data->payload;

			if (open->copp_id == INVALID_COPP_ID) {
				pr_err("%s: invalid coppid rxed %d\n",
					__func__, open->copp_id);
				atomic_set(&this_adm.copp.stat[port_idx]
						[copp_idx], ADSP_EBADPARAM);
				wake_up(
				&this_adm.copp.wait[port_idx][copp_idx]);
				break;
			}
			atomic_set(&this_adm.copp.stat
				[port_idx][copp_idx], payload[0]);
			atomic_set(&this_adm.copp.id[port_idx][copp_idx],
				   open->copp_id);
			pr_debug("%s: coppid rxed=%d\n", __func__,
				 open->copp_id);
			wake_up(&this_adm.copp.wait[port_idx][copp_idx]);
			}
			break;
		case ADM_CMDRSP_GET_PP_PARAMS_V5:
		case ADM_CMDRSP_GET_PP_PARAMS_V6:
			pr_debug("%s: ADM_CMDRSP_GET_PP_PARAMS\n", __func__);
			if (client_id == ADM_CLIENT_ID_SOURCE_TRACKING)
				this_adm.sourceTrackingData.apr_cmd_status =
					payload[0];
			else if (rtac_make_adm_callback(payload,
							data->payload_size))
				break;

			idx = ADM_GET_PARAMETER_LENGTH * copp_idx;
			if (payload[0] == 0 && data->payload_size > 0) {
				pr_debug("%s: Received parameter data in band\n",
					__func__);
				ret = adm_process_get_param_response(
					data->opcode, idx, payload,
					data->payload_size);
				if (ret)
					pr_err("%s: Failed to process get param response, error %d\n",
					       __func__, ret);
			} else if (payload[0] == 0 && data->payload_size == 0) {
				adm_get_parameters[idx] = -1;
				pr_debug("%s: Out of band case, setting size to %d\n",
					__func__, adm_get_parameters[idx]);
			} else {
				adm_get_parameters[idx] = -1;
				pr_err("%s: ADM_CMDRSP_GET_PP_PARAMS returned error 0x%x\n",
				       __func__, payload[0]);
			}
			atomic_set(&this_adm.copp.stat[port_idx][copp_idx],
				   payload[0]);
			wake_up(&this_adm.copp.wait[port_idx][copp_idx]);
			break;
		case ADM_CMDRSP_GET_PP_TOPO_MODULE_LIST:
		case ADM_CMDRSP_GET_PP_TOPO_MODULE_LIST_V2:
			pr_debug("%s: ADM_CMDRSP_GET_PP_TOPO_MODULE_LIST\n",
				 __func__);
			num_modules = payload[1];
			pr_debug("%s: Num modules %d\n", __func__, num_modules);
			if (payload[0]) {
				pr_err("%s: ADM_CMDRSP_GET_PP_TOPO_MODULE_LIST, error = %d\n",
				       __func__, payload[0]);
			} else if (num_modules > MAX_MODULES_IN_TOPO) {
				pr_err("%s: ADM_CMDRSP_GET_PP_TOPO_MODULE_LIST invalid num modules received, num modules = %d\n",
				       __func__, num_modules);
			} else {
				ret = adm_process_get_topo_list_response(
					data->opcode, copp_idx, num_modules,
					payload, data->payload_size);
				if (ret)
					pr_err("%s: Failed to process get topo modules list response, error %d\n",
					       __func__, ret);
			}
			atomic_set(&this_adm.copp.stat[port_idx][copp_idx],
				   payload[0]);
			wake_up(&this_adm.copp.wait[port_idx][copp_idx]);
			break;
		case ADM_CMDRSP_SHARED_MEM_MAP_REGIONS:
			pr_debug("%s: ADM_CMDRSP_SHARED_MEM_MAP_REGIONS\n",
				__func__);
			atomic_set(&this_adm.mem_map_handles[
				   atomic_read(&this_adm.mem_map_index)],
				   *payload);
			atomic_set(&this_adm.adm_stat, 0);
			wake_up(&this_adm.adm_wait);
			break;
		default:
			pr_err("%s: Unknown cmd:0x%x\n", __func__,
				data->opcode);
			break;
		}
	}
	return 0;
}

static int adm_memory_map_regions(phys_addr_t *buf_add, uint32_t mempool_id,
			   uint32_t *bufsz, uint32_t bufcnt)
{
	struct  avs_cmd_shared_mem_map_regions *mmap_regions = NULL;
	struct  avs_shared_map_region_payload *mregions = NULL;
	void    *mmap_region_cmd = NULL;
	void    *payload = NULL;
	int     ret = 0;
	int     i = 0;
	int     cmd_size = 0;

	pr_debug("%s:\n", __func__);
	if (this_adm.apr == NULL) {
		this_adm.apr = apr_register("ADSP", "ADM", adm_callback,
						0xFFFFFFFF, &this_adm);
		if (this_adm.apr == NULL) {
			pr_err("%s: Unable to register ADM\n", __func__);
			ret = -ENODEV;
			return ret;
		}
		rtac_set_adm_handle(this_adm.apr);
	}

	cmd_size = sizeof(struct avs_cmd_shared_mem_map_regions)
			+ sizeof(struct avs_shared_map_region_payload)
			* bufcnt;

	mmap_region_cmd = kzalloc(cmd_size, GFP_KERNEL);
	if (!mmap_region_cmd) {
		pr_err("%s: allocate mmap_region_cmd failed\n", __func__);
		return -ENOMEM;
	}
	mmap_regions = (struct avs_cmd_shared_mem_map_regions *)mmap_region_cmd;
	mmap_regions->hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
						APR_HDR_LEN(APR_HDR_SIZE),
								APR_PKT_VER);
	mmap_regions->hdr.pkt_size = cmd_size;
	mmap_regions->hdr.src_port = 0;

	mmap_regions->hdr.dest_port = 0;
	mmap_regions->hdr.token = 0;
	mmap_regions->hdr.opcode = ADM_CMD_SHARED_MEM_MAP_REGIONS;
	mmap_regions->mem_pool_id = ADSP_MEMORY_MAP_SHMEM8_4K_POOL & 0x00ff;
	mmap_regions->num_regions = bufcnt & 0x00ff;
	mmap_regions->property_flag = 0x00;

	pr_debug("%s: map_regions->num_regions = %d\n", __func__,
				mmap_regions->num_regions);
	payload = ((u8 *) mmap_region_cmd +
				sizeof(struct avs_cmd_shared_mem_map_regions));
	mregions = (struct avs_shared_map_region_payload *)payload;

	for (i = 0; i < bufcnt; i++) {
		mregions->shm_addr_lsw = lower_32_bits(buf_add[i]);
		mregions->shm_addr_msw =
				msm_audio_populate_upper_32_bits(buf_add[i]);
		mregions->mem_size_bytes = bufsz[i];
		++mregions;
	}

	atomic_set(&this_adm.adm_stat, -1);
	ret = apr_send_pkt(this_adm.apr, (uint32_t *) mmap_region_cmd);
	if (ret < 0) {
		pr_err("%s: mmap_regions op[0x%x]rc[%d]\n", __func__,
					mmap_regions->hdr.opcode, ret);
		ret = -EINVAL;
		goto fail_cmd;
	}

	ret = wait_event_timeout(this_adm.adm_wait,
				 atomic_read(&this_adm.adm_stat) >= 0,
				 5 * HZ);
	if (!ret) {
		pr_err("%s: timeout. waited for memory_map\n", __func__);
		ret = -EINVAL;
		goto fail_cmd;
	} else if (atomic_read(&this_adm.adm_stat) > 0) {
		pr_err("%s: DSP returned error[%s]\n",
				__func__, adsp_err_get_err_str(
				atomic_read(&this_adm.adm_stat)));
		ret = adsp_err_get_lnx_err_code(
				atomic_read(&this_adm.adm_stat));
		goto fail_cmd;
	}
fail_cmd:
	kfree(mmap_region_cmd);
	return ret;
}

static int adm_memory_unmap_regions(void)
{
	struct  avs_cmd_shared_mem_unmap_regions unmap_regions;
	int     ret = 0;

	pr_debug("%s:\n", __func__);
	if (this_adm.apr == NULL) {
		pr_err("%s: APR handle NULL\n", __func__);
		return -EINVAL;
	}

	unmap_regions.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
						APR_HDR_LEN(APR_HDR_SIZE),
							APR_PKT_VER);
	unmap_regions.hdr.pkt_size = sizeof(unmap_regions);
	unmap_regions.hdr.src_port = 0;
	unmap_regions.hdr.dest_port = 0;
	unmap_regions.hdr.token = 0;
	unmap_regions.hdr.opcode = ADM_CMD_SHARED_MEM_UNMAP_REGIONS;
	unmap_regions.mem_map_handle = atomic_read(&this_adm.
		mem_map_handles[atomic_read(&this_adm.mem_map_index)]);
	atomic_set(&this_adm.adm_stat, -1);
	ret = apr_send_pkt(this_adm.apr, (uint32_t *) &unmap_regions);
	if (ret < 0) {
		pr_err("%s: mmap_regions op[0x%x]rc[%d]\n", __func__,
				unmap_regions.hdr.opcode, ret);
		ret = -EINVAL;
		goto fail_cmd;
	}

	ret = wait_event_timeout(this_adm.adm_wait,
				 atomic_read(&this_adm.adm_stat) >= 0,
				 5 * HZ);
	if (!ret) {
		pr_err("%s: timeout. waited for memory_unmap\n",
		       __func__);
		ret = -EINVAL;
		goto fail_cmd;
	} else if (atomic_read(&this_adm.adm_stat) > 0) {
		pr_err("%s: DSP returned error[%s]\n",
				__func__, adsp_err_get_err_str(
				atomic_read(&this_adm.adm_stat)));
		ret = adsp_err_get_lnx_err_code(
				atomic_read(&this_adm.adm_stat));
		goto fail_cmd;
	} else {
		pr_debug("%s: Unmap handle 0x%x succeeded\n", __func__,
			 unmap_regions.mem_map_handle);
	}
fail_cmd:
	return ret;
}

static int remap_cal_data(struct cal_block_data *cal_block, int cal_index)
{
	int ret = 0;

	if (cal_block->map_data.ion_client == NULL) {
		pr_err("%s: No ION allocation for cal index %d!\n",
			__func__, cal_index);
		ret = -EINVAL;
		goto done;
	}

	if ((cal_block->map_data.map_size > 0) &&
		(cal_block->map_data.q6map_handle == 0)) {
		atomic_set(&this_adm.mem_map_index, cal_index);
		ret = adm_memory_map_regions(&cal_block->cal_data.paddr, 0,
				(uint32_t *)&cal_block->map_data.map_size, 1);
		if (ret < 0) {
			pr_err("%s: ADM mmap did not work! size = %zd ret %d\n",
				__func__,
				cal_block->map_data.map_size, ret);
			pr_debug("%s: ADM mmap did not work! addr = 0x%pK, size = %zd ret %d\n",
				__func__,
				&cal_block->cal_data.paddr,
				cal_block->map_data.map_size, ret);
			goto done;
		}
		cal_block->map_data.q6map_handle = atomic_read(&this_adm.
			mem_map_handles[cal_index]);
	}
done:
	return ret;
}

static void send_adm_custom_topology(void)
{
	struct cal_block_data		*cal_block = NULL;
	struct cmd_set_topologies	adm_top;
	int				cal_index = ADM_CUSTOM_TOP_CAL;
	int				result;

	if (this_adm.cal_data[cal_index] == NULL)
		goto done;

	mutex_lock(&this_adm.cal_data[cal_index]->lock);
	if (!this_adm.set_custom_topology)
		goto unlock;
	this_adm.set_custom_topology = 0;

	cal_block = cal_utils_get_only_cal_block(this_adm.cal_data[cal_index]);
	if (cal_block == NULL)
		goto unlock;

	pr_debug("%s: Sending cal_index %d\n", __func__, cal_index);

	result = remap_cal_data(cal_block, cal_index);
	if (result) {
		pr_err("%s: Remap_cal_data failed for cal %d!\n",
			__func__, cal_index);
		goto unlock;
	}
	atomic_set(&this_adm.mem_map_index, cal_index);
	atomic_set(&this_adm.mem_map_handles[cal_index],
		cal_block->map_data.q6map_handle);

	if (cal_block->cal_data.size == 0) {
		pr_debug("%s: No ADM cal to send\n", __func__);
		goto unlock;
	}

	adm_top.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
		APR_HDR_LEN(20), APR_PKT_VER);
	adm_top.hdr.pkt_size = sizeof(adm_top);
	adm_top.hdr.src_svc = APR_SVC_ADM;
	adm_top.hdr.src_domain = APR_DOMAIN_APPS;
	adm_top.hdr.src_port = 0;
	adm_top.hdr.dest_svc = APR_SVC_ADM;
	adm_top.hdr.dest_domain = APR_DOMAIN_ADSP;
	adm_top.hdr.dest_port = 0;
	adm_top.hdr.token = 0;
	adm_top.hdr.opcode = ADM_CMD_ADD_TOPOLOGIES;
	adm_top.payload_addr_lsw = lower_32_bits(cal_block->cal_data.paddr);
	adm_top.payload_addr_msw = msm_audio_populate_upper_32_bits(
						cal_block->cal_data.paddr);
	adm_top.mem_map_handle = cal_block->map_data.q6map_handle;
	adm_top.payload_size = cal_block->cal_data.size;

	atomic_set(&this_adm.adm_stat, -1);
	pr_debug("%s: Sending ADM_CMD_ADD_TOPOLOGIES payload = 0x%pK, size = %d\n",
		__func__, &cal_block->cal_data.paddr,
		adm_top.payload_size);
	result = apr_send_pkt(this_adm.apr, (uint32_t *)&adm_top);
	if (result < 0) {
		pr_err("%s: Set topologies failed payload size = 0x%zd result %d\n",
			__func__, cal_block->cal_data.size, result);
		goto unlock;
	}
	/* Wait for the callback */
	result = wait_event_timeout(this_adm.adm_wait,
				    atomic_read(&this_adm.adm_stat) >= 0,
				    msecs_to_jiffies(TIMEOUT_MS));
	if (!result) {
		pr_err("%s: Set topologies timed out payload size = 0x%zd\n",
			__func__, cal_block->cal_data.size);
		goto unlock;
	} else if (atomic_read(&this_adm.adm_stat) > 0) {
		pr_err("%s: DSP returned error[%s]\n",
				__func__, adsp_err_get_err_str(
				atomic_read(&this_adm.adm_stat)));
		result = adsp_err_get_lnx_err_code(
				atomic_read(&this_adm.adm_stat));
		goto unlock;
	}
unlock:
	mutex_unlock(&this_adm.cal_data[cal_index]->lock);
done:
	return;
}

static int send_adm_cal_block(int port_id, int copp_idx,
			      struct cal_block_data *cal_block, int perf_mode)
{
	struct mem_mapping_hdr mem_hdr = {0};
	int payload_size = 0;
	int port_idx = 0;
	int topology;
	int result = 0;

	pr_debug("%s: Port id 0x%x,\n", __func__, port_id);

	if (!cal_block) {
		pr_debug("%s: No ADM cal to send for port_id = 0x%x!\n",
			__func__, port_id);
		result = -EINVAL;
		goto done;
	}
	if (cal_block->cal_data.size <= 0) {
		pr_debug("%s: No ADM cal sent for port_id = 0x%x!\n", __func__,
			 port_id);
		result = -EINVAL;
		goto done;
	}

	port_id = afe_convert_virtual_to_portid(port_id);
	port_idx = adm_validate_and_get_port_index(port_id);
	if (port_idx < 0 || port_idx >= AFE_MAX_PORTS) {
		pr_err("%s: Invalid port_id 0x%x\n", __func__, port_id);
		return -EINVAL;
	} else if (copp_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT) {
		pr_err("%s: Invalid copp_idx 0x%x\n", __func__, copp_idx);
		return -EINVAL;
	}

	topology = atomic_read(&this_adm.copp.topology[port_idx][copp_idx]);
	if (perf_mode == LEGACY_PCM_MODE &&
	    topology == DS2_ADM_COPP_TOPOLOGY_ID) {
		pr_err("%s: perf_mode %d, topology 0x%x\n", __func__, perf_mode,
		       topology);
		goto done;
	}

	mem_hdr.data_payload_addr_lsw =
		lower_32_bits(cal_block->cal_data.paddr);
	mem_hdr.data_payload_addr_msw =
		msm_audio_populate_upper_32_bits(cal_block->cal_data.paddr);
	mem_hdr.mem_map_handle = cal_block->map_data.q6map_handle;
	payload_size = cal_block->cal_data.size;

	adm_set_pp_params(port_id, copp_idx, &mem_hdr, NULL, payload_size);

done:
	return result;
}

static struct cal_block_data *adm_find_cal_by_path(int cal_index, int path)
{
	struct list_head		*ptr, *next;
	struct cal_block_data		*cal_block = NULL;
	struct audio_cal_info_audproc	*audproc_cal_info = NULL;
	struct audio_cal_info_audvol	*audvol_cal_info = NULL;
	pr_debug("%s:\n", __func__);

	list_for_each_safe(ptr, next,
		&this_adm.cal_data[cal_index]->cal_blocks) {

		cal_block = list_entry(ptr,
			struct cal_block_data, list);

		if (cal_index == ADM_AUDPROC_CAL ||
		    cal_index == ADM_LSM_AUDPROC_CAL) {
			audproc_cal_info = cal_block->cal_info;
			if (audproc_cal_info->path == path)
				return cal_block;
		} else if (cal_index == ADM_AUDVOL_CAL) {
			audvol_cal_info = cal_block->cal_info;
			if (audvol_cal_info->path == path)
				return cal_block;
		}
	}
	pr_debug("%s: Can't find ADM cal for cal_index %d, path %d\n",
		__func__, cal_index, path);
	return NULL;
}

static struct cal_block_data *adm_find_cal_by_app_type(int cal_index, int path,
								int app_type)
{
	struct list_head		*ptr, *next;
	struct cal_block_data		*cal_block = NULL;
	struct audio_cal_info_audproc	*audproc_cal_info = NULL;
	struct audio_cal_info_audvol	*audvol_cal_info = NULL;
	pr_debug("%s\n", __func__);

	list_for_each_safe(ptr, next,
		&this_adm.cal_data[cal_index]->cal_blocks) {

		cal_block = list_entry(ptr,
			struct cal_block_data, list);

		if (cal_index == ADM_AUDPROC_CAL ||
		    cal_index == ADM_LSM_AUDPROC_CAL) {
			audproc_cal_info = cal_block->cal_info;
			if ((audproc_cal_info->path == path) &&
			    (audproc_cal_info->app_type == app_type))
				return cal_block;
		} else if (cal_index == ADM_AUDVOL_CAL) {
			audvol_cal_info = cal_block->cal_info;
			if ((audvol_cal_info->path == path) &&
			    (audvol_cal_info->app_type == app_type))
				return cal_block;
		}
	}
	pr_debug("%s: Can't find ADM cali for cal_index %d, path %d, app %d, defaulting to search by path\n",
		__func__, cal_index, path, app_type);
	return adm_find_cal_by_path(cal_index, path);
}


static struct cal_block_data *adm_find_cal(int cal_index, int path,
					   int app_type, int acdb_id,
					   int sample_rate)
{
	struct list_head		*ptr, *next;
	struct cal_block_data		*cal_block = NULL;
	struct audio_cal_info_audproc	*audproc_cal_info = NULL;
	struct audio_cal_info_audvol	*audvol_cal_info = NULL;
	pr_debug("%s:\n", __func__);

	list_for_each_safe(ptr, next,
		&this_adm.cal_data[cal_index]->cal_blocks) {

		cal_block = list_entry(ptr,
			struct cal_block_data, list);

		if (cal_index == ADM_AUDPROC_CAL ||
		    cal_index == ADM_LSM_AUDPROC_CAL) {
			audproc_cal_info = cal_block->cal_info;
			if ((audproc_cal_info->path == path) &&
			    (audproc_cal_info->app_type == app_type) &&
			    (audproc_cal_info->acdb_id == acdb_id) &&
			    (audproc_cal_info->sample_rate == sample_rate))
				return cal_block;
		} else if (cal_index == ADM_AUDVOL_CAL) {
			audvol_cal_info = cal_block->cal_info;
			if ((audvol_cal_info->path == path) &&
			    (audvol_cal_info->app_type == app_type) &&
			    (audvol_cal_info->acdb_id == acdb_id))
				return cal_block;
		}
	}
	pr_debug("%s: Can't find ADM cal for cal_index %d, path %d, app %d, acdb_id %d sample_rate %d defaulting to search by app type\n",
		__func__, cal_index, path, app_type, acdb_id, sample_rate);
	return adm_find_cal_by_app_type(cal_index, path, app_type);
}

static int adm_remap_and_send_cal_block(int cal_index, int port_id,
	int copp_idx, struct cal_block_data *cal_block, int perf_mode,
	int app_type, int acdb_id, int sample_rate)
{
	int ret = 0;

	pr_debug("%s: Sending cal_index cal %d\n", __func__, cal_index);
	ret = remap_cal_data(cal_block, cal_index);
	if (ret) {
		pr_err("%s: Remap_cal_data failed for cal %d!\n",
			__func__, cal_index);
		goto done;
	}
	ret = send_adm_cal_block(port_id, copp_idx, cal_block, perf_mode);
	if (ret < 0)
		pr_debug("%s: No cal sent for cal_index %d, port_id = 0x%x! ret %d sample_rate %d\n",
			__func__, cal_index, port_id, ret, sample_rate);
done:
	return ret;
}

static void send_adm_cal_type(int cal_index, int path, int port_id,
			      int copp_idx, int perf_mode, int app_type,
			      int acdb_id, int sample_rate)
{
	struct cal_block_data		*cal_block = NULL;
	int ret;

	pr_debug("%s: cal index %d\n", __func__, cal_index);

	if (this_adm.cal_data[cal_index] == NULL) {
		pr_debug("%s: cal_index %d not allocated!\n",
			__func__, cal_index);
		goto done;
	}

	mutex_lock(&this_adm.cal_data[cal_index]->lock);
	cal_block = adm_find_cal(cal_index, path, app_type, acdb_id,
				sample_rate);
	if (cal_block == NULL)
		goto unlock;

	ret = adm_remap_and_send_cal_block(cal_index, port_id, copp_idx,
		cal_block, perf_mode, app_type, acdb_id, sample_rate);
unlock:
	mutex_unlock(&this_adm.cal_data[cal_index]->lock);
done:
	return;
}

